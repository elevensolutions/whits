import {htmlElementAttributes} from 'html-element-attributes';
import {svgElementAttributes} from 'svg-element-attributes';
import {htmlTagNames} from 'html-tag-names';
import {svgTagNames} from 'svg-tag-names';
import {createWriteStream} from 'fs';
import {promisify} from 'util';

function openFile(path) {
	const output = createWriteStream(path, {flags: 'w'});
	return promisify(output.write).bind(output);
}

/**
 * Generates the HTML or SVG tag and attribute types.
 * @param {'html' | 'svg'} language The language to generate the types for.
 */
async function run(language) {
	const attributes = language === 'html' ? htmlElementAttributes : svgElementAttributes;
	const tagNames = language === 'html' ? htmlTagNames.filter((tag) => tag !== 'svg') : svgTagNames;
	const L = language.toUpperCase();
	const l = L[0] + language.slice(1);

	const globalTypes = attributes['*'];
	delete attributes['*'];
	const attrMap = Object.entries(attributes);
	attrMap.push(...tagNames.filter((tag) => !attrMap.find(([attrTag]) => attrTag === tag)).map((tag) => [tag, []]));
	const attrMapString = attrMap.map(([tag, types]) => `\t'${tag}': ${types.map((value) => `'${value}'`).join(' | ') || 'undefined'};`);


	// Write attributes
	const writeAttrs = openFile(`src/${language}Attributes.ts`);
	await writeAttrs(`// DO NOT EDIT THIS FILE - These types are generated by running \`npm run tags\`

		import type {Tag} from './tag/tag.js';
		import type {SelectorPart} from './tag/selector.js';

		/** Union of attributes that are valid on all ${L} tags. */
		export type ${l}GlobalAttribute = ${globalTypes.map((value) => `'${value}'`).join(' | ')};

		/** The tag-specific attributes that are valid for each ${L} tag. */
		export interface ${l}BaseAttributeMap {
			${attrMapString.join('\n')}
		}

		/** Overrrides to allow extending with new ${L} tags and/or attributes. */
		export interface ${l}AttributeOverrides {}

		/** A map of all valid ${L} tags and attributes, including user overrides. */
		export type ${l}AttributeMap = {
			[K in keyof ${l}BaseAttributeMap | keyof ${l}AttributeOverrides]:
				(K extends keyof ${l}BaseAttributeMap ? ${l}BaseAttributeMap[K] : never) |
				(K extends keyof ${l}AttributeOverrides ? ${l}AttributeOverrides[K] : never)
		};

		/** A valid ${L} tag name. */
		export type ${l}TagName = keyof ${l}AttributeMap;

		/**
		 * A valid ${L} attribute name for the \`T\` tag.
		 * @template T The tag to which the attribute applies.
		 */
		export type ${l}Attribute<T extends ${l}TagName> = ${l}AttributeMap[T] extends string ? ${l}AttributeMap[T] : never;
		
		/**
		 * An object that represents the attributes of an ${L} tag.
		 * It is a record type that maps attribute names to their values.
		 * @template T The ${L} tag name.
		 */
		export type ${l}Attributes<T extends ${l}TagName> = Record<${l}Attribute<T> | \`data-\${string}\` | ${l}GlobalAttribute, string | boolean>;

		/**
		 * A type that represents any ${L} tag.
		 * It is a mapped type that iterates over all possible ${L} tag names and returns the corresponding Tag type.
		 */
		export type Any${l}Tag = {[K in ${l}SelectorString]: Tag<K>}[${l}SelectorString];

		/**
		 * A type that represents any ${L} tag that is user-defined.
		 */
		export type Artificial${l}Tag = {[K in keyof ${l}AttributeOverrides]: K extends keyof ${l}BaseAttributeMap ? never : K}[keyof ${l}AttributeOverrides];

		/**
		 * A string that represents a CSS selector for an ${L} tag.
		 */
		export type ${l}SelectorString = {[K in ${l}TagName]: \`\${K}\${SelectorPart}\`}[${l}TagName] | SelectorPart;
	`.replace(/^(\t{2,3}|\t+$)/gm, ''));

	// Write tags
	const writeTags = openFile(`src/tag/${language}Tags.ts`);
	await writeTags(`import {tagFactory as $} from './factory.js';\n\n`);
	await writeTags(`export const ${language}Tags = {\n`);
	for (const [tag] of attrMap) await writeTags(`\t'${tag}': $('${tag}'),\n`);
	await writeTags(`} as const;\n`);
}

await run('html');
await run('svg');
